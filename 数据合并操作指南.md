# 数据合并操作指南（Excel Power Query方法）

如果Python环境暂时无法使用，可以使用Excel的Power Query功能完成数据合并。

## 方法一：使用Excel Power Query合并（推荐）

### 准备工作
1. 新建一个Excel文件，命名为`总数据集.xlsx`
2. 打开Excel，进入"数据"选项卡
3. 点击"获取数据" → "来自文件" → "来自工作簿"

### 步骤1：加载产业结构数据
1. 选择`2000-2023地级市产业结构 - 面板.xls`
2. 在导航器中选择包含数据的Sheet
3. 点击"转换数据"进入Power Query编辑器
4. 检查并重命名关键列：
   - 城市代码列 → `city_code`
   - 年份列 → `year`
   - 城市名称列 → `city_name`
5. 点击"关闭并加载"（选择"仅创建连接"）

### 步骤2：添加GDP数据
1. 在Power Query编辑器中，点击"新建源" → "来自文件" → "来自工作簿"
2. 选择`296个地级市GDP相关数据（以2000年为基期）.xlsx`
3. 重命名关键列为`city_code`和`year`
4. 点击"关闭并加载"（仅创建连接）

### 步骤3：添加人口密度数据
1. 同样方式加载`298个地级市人口密度1998-2024年无缺失.xlsx`
2. 重命名关键列

### 步骤4：添加碳排放数据
1. 加载`地级市碳排放强度.xlsx`
2. 重命名关键列

### 步骤5：执行合并查询
1. 在Power Query中，选择产业结构数据查询
2. 点击"合并查询" → "将查询作为新合并"
3. 第一个表：产业结构数据
4. 第二个表：GDP数据
5. 匹配依据：按住Ctrl键，选择`city_code`和`year`两列
6. 联接种类：左外部（Left Outer）
7. 点击确定

### 步骤6：展开合并的列
1. 在合并后的新列标题上点击右边的扩展图标（两个箭头）
2. 选择要展开的列（取消勾选不需要的列，如city_code、year）
3. 点击确定

### 步骤7：重复合并
1. 将上一步的结果与人口密度数据合并（同样方法）
2. 再将结果与碳排放数据合并
3. 最终得到包含所有变量的完整数据集

### 步骤8：导出数据
1. 在Power Query编辑器中，点击"关闭并加载"
2. 数据将加载到Excel工作表中
3. 保存Excel文件

---

## 方法二：使用VLOOKUP/XLOOKUP函数（备选）

如果数据量不大，可以使用Excel公式：

### 在产业结构数据表中添加新列：

**添加GDP数据：**
```
=XLOOKUP(city_code & "-" & year, GDP数据!city_code列 & "-" & GDP数据!year列, GDP数据!要返回的列)
```

**添加人口密度数据：**
```
=XLOOKUP(city_code & "-" & year, 人口密度数据!city_code列 & "-" & 人口密度数据!year列, 人口密度数据!人口密度列)
```

**添加碳排放数据：**
```
=XLOOKUP(city_code & "-" & year, 碳排放数据!city_code列 & "-" & 碳排放数据!year列, 碳排放数据!碳排放强度列)
```

---

## 方法三：Python脚本（等环境配置好后执行）

保存以下代码为`merge_datasets.py`并运行：

```python
import pandas as pd
from pathlib import Path

# 设置数据路径
DATA_DIR = Path(r"c:\Users\HP\Desktop\毕业论文\原始数据")
OUTPUT_FILE = Path(r"c:\Users\HP\Desktop\毕业论文\总数据集.xlsx")

# 读取数据
print("正在读取数据...")
df_industrial = pd.read_excel(DATA_DIR / "2000-2023地级市产业结构 - 面板.xls")
df_gdp = pd.read_excel(DATA_DIR / "296个地级市GDP相关数据（以2000年为基期）.xlsx")
df_pop = pd.read_excel(DATA_DIR / "298个地级市人口密度1998-2024年无缺失.xlsx")
df_carbon = pd.read_excel(DATA_DIR / "地级市碳排放强度.xlsx")

# 显示列名
print("\n产业结构数据列:", df_industrial.columns.tolist())
print("\nGDP数据列:", df_gdp.columns.tolist())
print("\n人口密度数据列:", df_pop.columns.tolist())
print("\n碳排放数据列:", df_carbon.columns.tolist())

# 根据实际列名修改以下代码
# 假设城市代码列名为"城市代码"，年份列名为"年度"或"年份"

# 重命名主键列（根据实际情况修改）
def standardize_columns(df, city_col, year_col):
    df = df.rename(columns={city_col: 'city_code', year_col: 'year'})
    return df

# 示例：需要根据实际列名修改
# df_industrial = standardize_columns(df_industrial, '城市代码', '年度')
# df_gdp = standardize_columns(df_gdp, '城市代码', '年份')
# df_pop = standardize_columns(df_pop, '城市代码', '年份')
# df_carbon = standardize_columns(df_carbon, '城市代码', '年份')

# 合并数据
print("\n正在合并数据...")
df_merged = df_industrial.merge(df_gdp, on=['city_code', 'year'], how='left', indicator='gdp_source')
df_merged = df_merged.merge(df_pop, on=['city_code', 'year'], how='left', indicator='pop_source')
df_merged = df_merged.merge(df_carbon, on=['city_code', 'year'], how='left', indicator='carbon_source')

# 显示合并结果
print(f"\n合并后数据形状: {df_merged.shape}")
print(f"唯一城市数: {df_merged['city_code'].nunique()}")
print(f"年份范围: {df_merged['year'].min()} - {df_merged['year'].max()}")

# 检查缺失值
print("\n缺失值统计:")
print(df_merged.isnull().sum())

# 保存结果
print(f"\n正在保存到: {OUTPUT_FILE}")
df_merged.to_excel(OUTPUT_FILE, index=False, sheet_name='总数据集')
print("完成！")
```

---

## 合并后的质量检查清单

完成合并后，请检查：

- [ ] 1. 数据行数是否合理？（预期3500-4000行）
- [ ] 2. 是否有重复的city_code-year组合？
- [ ] 3. 所有城市代码是否都是6位数字？
- [ ] 4. 年份是否在2010-2023范围内？
- [ ] 5. 关键变量（GDP、人口密度、碳排放）的缺失率是否低于5%？
- [ ] 6. 是否存在极端异常值？（如人口密度<0或>100000）

---

## 常见问题解决

### Q1: 合并后数据行数异常多
**A:** 检查是否有重复的主键，使用Excel的"删除重复值"功能

### Q2: 大量缺失值
**A:** 可能是城市代码不匹配，检查不同数据集的城市代码格式是否一致

### Q3: 合并后某些变量全部为空
**A:** 检查合并时选择的匹配键是否正确，可能是列名选择错误

---

**更新时间：** 2025年1月2日
**建议工具：** Excel Power Query（无需编程，操作直观）
